/*                        options.h配置详细选项
----------------------------------------------------------------------------
 将 MudOS 下载解压以后可以在相应目录的根目录中找到 options.h 这个文件。如果修
 改了这个文件，那么每次都需要重新编译 MudOS 才能生效。重新编译之前，请执行 ma
 ke clean 一下。
 下面的 options.h 来自 MudOSv22.2b10，MudOS作者推荐在修改options.h 之前，先将
 它备份成 local_options。新的特性将会自动对比local_options并且在编译的时候告知
 。文中的选项定义并非最原始的定义。此文只是为了说明各个选项的大致含义。
 options.h: defines for the compile-time configuration of the MudOS driver
*/

#ifndef _OPTIONS_H_
#define _OPTIONS_H_

/****************************************************************************
 如果你对自己的系统不熟悉，请使用缺省的定义 SYSMALLOC，同时将其它的undef掉。
 你必须选择下面的其中一种定义，并且将其它的定义undef掉。
 SYSMALLOC: 缺省选项，没有额外的系统开支，没有统计能力。
 SMALLOC:速度比较快，但是开销相对大一些。
 BSDMALLOC:速度更快，开销比较大。
 ****************************************************************************/

#define SYSMALLOC
#undef SMALLOC
#undef BSDMALLOC

/****************************************************************************
 WRAPPEDMALLOC:这个附加定义可以换来有限的统计能力，并且不会增加太多的系统开销。
 DEBUGMALLOC:系统花费比较折中
 ****************************************************************************/
#undef WRAPPEDMALLOC
#undef DEBUGMALLOC

/****************************************************************************
 如果没有定义SMALLOC，请不要使用下面这个定义。
 ****************************************************************************/
#undef SBRK_OK
 
/****************************************************************************
 如果没有定义 BSDMALLOC or SMALLOC ，请不要使用下面这个定义
 ****************************************************************************/
#undef DO_MSTATS

/****************************************************************************
 DEBUGMALLOC定义的附加定义，用来强化DEBUGMALLOC，但是需要更多的开销。
 set_malloc_mask(int) and debugmalloc(string,int)等efuns将可以被使用。
 ****************************************************************************/
#undef DEBUGMALLOC_EXTENSIONS

/****************************************************************************
 同上，是用来调试的良好定义，check_memory() efun将可以被使用。
 ****************************************************************************/
#undef CHECK_MEMORY

/****************************************************************************
 兼容性定义选项：
 由于MudOS发展了很多年，所以历代MudOS为了保证原有的Lib可以不修改就被移植到新的
 OS上面，增加了这些兼容性选项。如果你是根据OS撰写Lib的人，可以定义一些优化的选
 项来设计自己的Lib，而不必考虑重写的问题。
 以前的MudOS使用status这样子的定义词，这是很老的定义了，对于新的Lib设计而言，
 这个定义毫无用处。
 ****************************************************************************/
#undef HAS_STATUS_TYPE

/****************************************************************************
 explode()选项，这个根据个人的习惯来定义吧
 如果不定义下面两个选项， explode("..x.y..z..", ".") 的结果是 ({ "x", "y", ""
 , "z", "" })
 如果定义SANE_EXPLODE_STRING 选项，其结果将是({ "", "x", "y", "", "z", "" })
 如果定义 REVERSIBLE_EXPLODE_STRING 选项，其结果将是 ({ "", "", "x", "y", "",
 "z", "", "" })
 ****************************************************************************/
#define SANE_EXPLODE_STRING
#undef REVERSIBLE_EXPLODE_STRING

/****************************************************************************
 这个选项用来确定call_other的行为，但是这个选项对于系统毫无好处可言。
 ****************************************************************************/
#undef CAST_CALL_OTHERS

/****************************************************************************
 如果定义了下面这个选项，那么任何传往非交互式物件（比如npc）的信息前面都会被加
 上']'符号，这个也不是非常需要，而且很容易被模拟出来。
 ****************************************************************************/
#define NONINTERACTIVE_STDERR_WRITE

/****************************************************************************
 如果定义下面这个选项，你将不能使用set_light()这样的efuns函数，不过没有关系，
 这个函数是在太落伍了，这个功能非常容易被模拟出来。
 ****************************************************************************/
#define NO_LIGHT

/****************************************************************************
 嗯，下面这个选项，是非常重要的选项，如果你定义了，那么意味着你将不能使用add_
 action, commands, livings等等这些相关的efuns，而不得不使用 process_input() 这
 样的函数来定义物件所有的动作。这将是非常难堪的工作。所以保持add_action还是非
 常有用的。
 ****************************************************************************/
#undef NO_ADD_ACTION

/****************************************************************************
 定义下面这个选项，将不能使用和snoop相关的函数，如果你认为没有snoop也没有关系
 ，可以定义这个选项来保护一些隐私。
 ****************************************************************************/
#undef NO_SNOOP

/****************************************************************************
 这个选项和add_action一样要命，除非你立志只做一个聊天室，那么可以定义这个选项
 ，否则，你的工作将会非常的麻烦。
 ****************************************************************************/
#undef NO_ENVIRONMENT

/****************************************************************************
 由于历史原因，定义wizard来管理Mud的运作，但是现在好像不是非常重要了。
 如果定义了, wizardp() 和 related efuns 将不存在
 如果没有定义，在使用ed()时也受限制，设置的限制参数无效
 而且这个定义非常容易模拟出来。
 ****************************************************************************/
#undef NO_WIZARDS

/****************************************************************************
 下面的选项只是为了保持兼容性问题，对于大多数的LPmud而言，这个选项毫无用处。尤
 其是一个新的Lib撰写。
 ****************************************************************************/
#undef OLD_TYPE_BEHAVIOR

/****************************************************************************
 定义下面这个选项，将意味着对于一个string或者buffers而言可以使用负数的index。
 对于一个新Lib撰写，这个属性不是非常重要。
 ****************************************************************************/
#undef OLD_RANGE_BEHAVIOR

/****************************************************************************
 这个定义选项主要是为了保持向后兼容，对于新的Lib而言，没什么用处。重新习惯一个
 方式，并不是非常困难的，而且，ed()对于大多数习惯使用工具撰写的人们而言，意义
 不大。
 ****************************************************************************/
#define OLD_ED

/****************************************************************************
 下面这个选项比较重要，对于新的Lib撰写或者以前没有接触过LPC的人来说，这个定义
 可以按照喜好来定。
 (1) 'static' 将不再使用，而是用 'nosave' 或者 'protected' 代替了它。.
 (2) 'public' 含义发生了变化，外部函数必须在任何一级的继承中被声明。现在publi
 c意味着是明显可见的。
 ****************************************************************************/
#define SENSIBLE_MODIFIERS

/****************************************************************************
 下面的选项定义会改变MudOS的一些行为。这些对于Lib撰写，是比较重要的。
 定义下面这个选项，将使用MD5加密法代替系统缺省的crypt()加密法。
 ****************************************************************************/
#undef CUSTOM_CRYPT

/****************************************************************************
 下面这个选项只是为了一些兼容性问题。定义以后，某些efuns含义会有所变化，但是没
 有实质的区别。
 ****************************************************************************/
#undef COMPAT_32

/****************************************************************************
 允许统计的时候包含字符串分配，不定义可以是字符串处理更快，但字符串统计将被忽略。
 ****************************************************************************/
#define STRING_STATS

/****************************************************************************
 同上，数组统计。
 ****************************************************************************/
#define ARRAY_STATS

/****************************************************************************
 这是比较有用的选项，用来生成log文件。
 ****************************************************************************/
#define LOG_CATCHES

/****************************************************************************
 这个类似上面得选项，可以生成有用的调试文档。
 ****************************************************************************/
#define ARGUMENTS_IN_TRACEBACK

/****************************************************************************
 同上，对于新Lib撰写非常有用。
 ****************************************************************************/
#define LOCALS_IN_TRACEBACK

/****************************************************************************
 通过error_handler()来处理错误，非常有用的选项。
 ****************************************************************************/
#define MUDLIB_ERROR_HANDLER

/****************************************************************************
 下面得选项，可以详细定义，当然也可以通过配置config.cfg这样的文件来设置。
 ****************************************************************************/
#ifndef LATTICE
#define CONFIG_FILE_DIR "/u/tim/COMP/bin"
#else
#define CONFIG_FILE_DIR "etc:"
#endif

/****************************************************************************
 下面的选项将会对整个Lib撰写起到作用。对于新的Lib撰写，建议选择比较严格的方式
 。而如果想保持兼容，建议选择常规的设定。
 这些设定　其实等同于使用 #pragma　来定义。
 如果你不太明白，使用 #define DEFAULT_PRAGMAS 0　是一个比较好的选择。
  PRAGMA_STRICT_TYPES: 强制执行严格的书写规则，这个估计是以前议论最多的问题，
                       事实上，对于新Lib，这几乎不是问题。
  PRAGMA_WARNINGS: 对不合法代码进行警告。非常有用。
  PRAGMA_SAVE_TYPES: 呼叫以后保存函数情况
  PRAGMA_SAVE_BINARY: 二进制代码保存，可以降低系统负担。
  PRAGMA_OPTIMIZE: 代码优化
  PRAGMA_ERROR_CONTEXT:错误报告
 ****************************************************************************/
#define DEFAULT_PRAGMAS PRAGMA_SAVE_BINARY + PRAGMA_OPTIMIZE + PRAGMA_WARNINGS + PRAGMA_ERROR_CONTEXT

/****************************************************************************
 对于没有使用的变量声明或者缺少的参数进行报告
 ****************************************************************************/
#define SUPPRESS_ARGUMENT_WARNINGS

/****************************************************************************
 这是重要的设定，为了保证系统拥有reset()，请不要定义这个选项。
 除非不想系统拥有reset()。
 ****************************************************************************/
#undef NO_RESETS

/****************************************************************************
 看名字就知道，如果定义了，reset()将变得比较懒惰，你不碰它，它不呼叫。对于大多
 数需要刷新时间的LPmud而言，还是不要定义的好。
 ****************************************************************************/
#undef LAZY_RESETS

/****************************************************************************
 存盘文件的缺省后缀名。
 ****************************************************************************/
#define SAVE_EXTENSION ".o"

/****************************************************************************
 下面两个选项使用来控制ansi的用户输入的，这个比较容易模拟出来，因为自由的ansi
 输入可能会导致一些显示错误。
 ****************************************************************************/
#define NO_ANSI
#define STRIP_BEFORE_PROCESS_INPUT

/****************************************************************************
 笔者水平有限，不知道OPC是什么东西。只知道定义以后，可以用一个opcprof()函数来
 统计外部函数调用的情况。下面得选项稍有不同，一次只能定义其中的一个。
 ****************************************************************************/
#undef OPCPROF
#undef OPCPROF_2D

/****************************************************************************
 当这个选项定义以后，当发生crash的时候，master.c中定义的crash()将被呼叫。
 ****************************************************************************/
#define TRAP_CRASHES

/****************************************************************************
 可以在call_outs中使用this_player()
 ****************************************************************************/
#define THIS_PLAYER_IN_CALL_OUT

/****************************************************************************
 这个定义是比较有用的，定义以后，call_out将产生一个int序列，这个序列可以方便的
 被find_call_out()和remove_call_out()调用。这是一个效率极高的处理方式。原来使
 用name来处理的方式相对比较低效。唯一的代价是些许系统开销。
 ****************************************************************************/
#define CALLOUT_HANDLES

/****************************************************************************
 调试非常有用，一般情况下不需要。
 ****************************************************************************/
#undef FLUSH_OUTPUT_IMMEDIATELY

/****************************************************************************
 这个定义允许在Lib中给与一些object以特权，除非你非常了解这个定义对于你所要撰写
 的Lib的用处，不然的话，不要定义这个。
 ****************************************************************************/
#undef PRIVS

/****************************************************************************
 下面这个定义可以使互动物件也适用catch_tell()，当然你就必须在user.c中写入catc
 h_tell()来处理receive(msg)。
 ****************************************************************************/
#undef INTERACTIVE_CATCH_TELL

/****************************************************************************
 受限制的ed模式
 ****************************************************************************/
#define RESTRICTED_ED

/****************************************************************************
 使用下面这个定义，你就不能在想要撰写的Lib中使用shadow，而shadow往往非常有用，
 所以除非你明确知道不需要，不然不要定义这个选项。
 ****************************************************************************/
#undef NO_SHADOWS

/****************************************************************************
 定义下面这个，可以snoop shadowed object，因为shadowed object可能不知道送过来
 的msg。
 ****************************************************************************/
#undef SNOOP_SHADOWED

/****************************************************************************
 这是一个有趣的定义，可以让你监听snooper的msg，也许利用起来比较有趣。当然也可
 以不定义它。
 ****************************************************************************/
#define RECEIVE_SNOOP

/****************************************************************************
 这不是一个非常准确的定义，如果你想知道物件调用函数的时候，使用了多少时间，可
 以用这个试试。不过不要对它的准确性基于太多的希望。
 ****************************************************************************/
#undef PROFILE_FUNCTIONS

/****************************************************************************
 'buffer'这个类型定义的选择，按所要撰写的Lib而定，如果你可能要用到这种变量定义
 ，就不要定义这个选项。
 ****************************************************************************/
#undef NO_BUFFER_TYPE

/****************************************************************************
 设置 pragma　'save_binary'　的有效性。
 使用这个选项，可以是Lib运行速度有所提高，并且降低系统的开销。代价就是将占用更
 多的硬盘空间。
 ****************************************************************************/
#define BINARIES

/****************************************************************************
 允许定义数组变量，关键字array。比如 int array x = ({...});
 不过估计这样定义也不会有人反对 int *x = ({});
 定义这个选项与否，主要是看是不是习惯使用array这个声明，如果你来自C或者java，
 也许会喜欢的。
 ****************************************************************************/
#undef ARRAY_RESERVED_WORD

/****************************************************************************
 这个同上，关键字ref。按照Lib撰写人的习惯来定义比较好。
 ****************************************************************************/
#undef REF_RESERVED_WORD

/****************************************************************************
                              扩充包是可选配件 
 如果你定义了PACKAGE_XYZZY，那么你可以参看 packages/xyzzy.c　中的函数来确定可
 以使用哪些efuns。
 确定使用哪些扩充包，主要取决于提供的efuns是否是需要的。
 这个扩充包的函数还是非常有用的，比如query_ip_port() repeat_string()等等。
 ****************************************************************************/
#define PACKAGE_CONTRIB

/****************************************************************************
 下面这个包主要用来了解driver内部的信息。
 ****************************************************************************/
#define PACKAGE_DEVELOP

/****************************************************************************
 一些数学计算式，还是比较有用的。
 ****************************************************************************/
#define PACKAGE_MATH

/****************************************************************************
 这个是图像处理包，不过，笔者也没用过。
 ****************************************************************************/
#undef PACKAGE_MATRIX

/****************************************************************************
 这个包的函数用来了解Mudlib的数据，比较实用。
 ****************************************************************************/
#undef PACKAGE_MUDLIB_STATS

/****************************************************************************
 呵呵，这个当然非常有用了。
 ****************************************************************************/
#define PACKAGE_SOCKETS

/****************************************************************************
 这个用处不大，尤其是中文使用者，呵呵
 ****************************************************************************/
#undef PACKAGE_PARSER

/****************************************************************************
 这个也没什么大的用处。允许driver在config文件里exe()命令清单
 ****************************************************************************/
#undef PACKAGE_EXTERNAL

/****************************************************************************
 外部扩展指令支持的数目
 ****************************************************************************/
#ifdef PACKAGE_EXTERNAL
#define NUM_EXTERNAL_CMDS
#endif

/****************************************************************************
 数据库支持包，想用数据库mysql的Lib撰写者比较有用，
 ****************************************************************************/
#undef PACKAGE_DB

/****************************************************************************
 如果PACKAGE_DB被定义，必须选择下面中的一个来支持数据库
 ****************************************************************************/
#ifdef PACKAGE_DB
#define USE_MSQL 1		/* MiniSQL, it's small; it's free */
#undef USE_MYSQL 2		/* MySQL, bigger; it's free */
#define DEFAULT_DB USE_MSQL	/* default database */
#endif

/****************************************************************************
 　　UID，就是用户有效识别码，国内的LPMud大多基于 wizard 以及 uid 系统，如果不
 是新Lib的撰写者，这个是比较有用的。如果你拥有了自己的理念，可以不使用这些定义
 。从MudOS开发者来看，他们也没有明确说不需要这些。虽然本人倒是比较喜欢放弃这些
 设定，但是这些设定的存在，确实可以方便很多的处理。
 如果你打算使用UID，那就定义下面这个选项。
 ****************************************************************************/
#define PACKAGE_UIDS

/****************************************************************************
 自动设定UID，那就不需要每次都seteuid(getuid(this_object()))。如果需要seteuid
 (0)，那么不要定义这个，比如现在大多数的Lib。
 ****************************************************************************/
#define AUTO_SETEUID

/****************************************************************************
 backbone这个设定是被自动认可的。
 ****************************************************************************/
#define AUTO_TRUST_BACKBONE

/****************************************************************************
 下面这些设定，一般情况下，不需要做出大的调整。
 资源问题，使用32位地址。
 ****************************************************************************/
#undef USE_32BIT_ADDRESSES

/****************************************************************************
 心跳时间，这里是两秒。
 ****************************************************************************/
#define HEARTBEAT_INTERVAL 2000000

/****************************************************************************
 call_out的设定
 ****************************************************************************/
#define CALLOUT_CYCLE_SIZE 32

/****************************************************************************
 信息暂存设定
 ****************************************************************************/
#define LARGEST_PRINTABLE_STRING 8192

/****************************************************************************
 输出信息buffer设定
 ****************************************************************************/
#define MESSAGE_BUFFER_SIZE 4096

/****************************************************************************
 定义call_other cache的bits number
  6 64 1k
  8 256 4k
  10 1024 16k
  12 4096 64k
  14 16384 256k
  16 65536 1M
 ****************************************************************************/
#define APPLY_CACHE_BITS 12

/****************************************************************************
 call_other的cache统计
 ****************************************************************************/
#define CACHE_STATS

/****************************************************************************
 不定义可以快一点。
 ****************************************************************************/
#undef TRACE

/****************************************************************************
 LPC->C的编译
 ****************************************************************************/
#define LPC_TO_C

/****************************************************************************
 看系统而定，一般不需要定义。
 ****************************************************************************/
#undef RUNTIME_LOADING

/****************************************************************************
 这个定义以后，允许被跟踪执行。
 ****************************************************************************/
#undef TRACE_CODE

/****************************************************************************
 缺省设定是32，主要关系到 heart_beat 的系统开销。
 ****************************************************************************/
#define HEART_BEAT_CHUNK      32

/****************************************************************************
 一般情况下，get_char不是bufferd。所以不太必要定义这个选项。
 ****************************************************************************/
#undef GET_CHAR_IS_BUFFERED

/****************************************************************************
 字符串定义。
 ****************************************************************************/
#define SMALL_STRING_SIZE     100
#define LARGE_STRING_SIZE     1000

/****************************************************************************
 呵呵，如果dbase深度超过了25就会溢出，这个设定就是这里定义的。当年最常见的一个
 当机bug就是set指令的dbase溢出导致的。
 ****************************************************************************/
#define MAX_SAVE_SVALUE_DEPTH 25

/****************************************************************************
 25个局部变量调用，对于一个函数来说，应该是够了。数数COMBAT_D中的attack()函数
 用到了几个局部变量。本人曾经定义超过25个变量，结果导致出错，但是那个时候不知
 道为什么，虽然预感到这一点，但是没想过怎么解决。
 ****************************************************************************/
#define CFG_MAX_LOCAL_VARIABLES		40
#define CFG_EVALUATOR_STACK_SIZE 	1000
#define CFG_MAX_CALL_DEPTH		50

/****************************************************************************
 下面定义的必须选择 4, 16, 64, 256, 1024, 4096 中的一个数字 
 ****************************************************************************/
#define CFG_LIVING_HASH_SIZE		256

/****************************************************************************
  NEXT_MALLOC_DEBUG: define this if using a NeXT and you want to enable
    the malloc_check() and/or malloc_debug() efuns.  Run the 'man malloc_debug'
    command on the NeXT to find out what the arguments to malloc_debug(int)
    mean.  The malloc_check() efun calls the NeXT NXMallocCheck() system
    call which does a consistency check on malloc's data structures (this
    consistency check is done at each malloc() and free() for certain
    malloc_debug() levels).  A non-zero return value indicates there was
    a consistency problem.  For those NeXT users wanting a bit more
    performance out of malloc, try defining NEXT_MALLOC_DEBUG and calling the
    malloc_debug(-1) efun (with an arg of -1).  This will turn all
    malloc debugging off and call malloc_singlethreaded() which the NeXT
    malloc man page claims can make NeXT system malloc 10% to 15% faster.
 
  [NOTE: This #define has no affect on the driver if not using the
   NeXTSTEP OS.]
 
  Warning: if you use a NeXT and define NEXT_MALLOC_DEBUG, be sure to
           protect the use of the malloc_check() and malloc_debug() efuns
           since setting certain debug levels can cause malloc() and free()
           to become _very_ slow (protect efuns by using simul_efuns and
           valid_override).
 
  [NOTE: malloc_debug(6) is a good compromise between efficiency and
   completeness of malloc debugging (malloc/free will be about half as fast).]
 ****************************************************************************/
#define NEXT_MALLOC_DEBUG

#endif
